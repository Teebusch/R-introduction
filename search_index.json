[["index.html", "10 Reasons to Learn R Welcome Who is this for? The origins of this book About the author", " 10 Reasons to Learn R Tobias Busch 2021-07-26 Welcome This book is a short hands-on introduction to R. The goal is to provide a quick overview of things that are great about R so that you can decide whether diving deeper is worth your time. We will start with a brief introducing to R, followed by a discussion of good reasons not to learn R and some worthwile alternatives. Then we turn to the things that R has to offer: I will present ten things that I love about R and along with that, you will get some hands-on experience. The book uses modern R, with RStudio, RMarkdown, and the Tidyverse. It focuses on the parts that are most essential for reproducible data analysis and keeps the technical details to a minimum. After reading it, you will have a basic understanding of data analysis in R and should be able to decide whether you want to continue learning. This is a draft! This book is a work in progress and nobody knows if and when it will ever be finished. Who is this for? This book is written for someone who already has some experience with doing data analysis using other tools but now wants to learn more about R. Your motivation might be that… You are afraid of missing out and want to know what all the fuzz is about You feel that your current workflow isn’t reproducible or efficient enough, and you believe that R might help you with that There is a statistical method that you would like to use, that is not available in your preferred software but it is available in R You unsuccessfully tried to learn R before, but would like to try again I’m assuming you have no or very little programming experience and you are not particularly interested in computer programming.1 You don’t want to be bored with technical background knowledge. You are here, because you want to learn tools that can help you get things done, and you wonder if R might be one of them. The origins of this book This book started as my notes for a workshop I gave in April 2021 at a research group meeting at the University of Oslo’s Department of Special Needs Education. It was a 90 minutes long hands-on introduction to R with the goal to provide an overview of R. After the workshop, I continued to expand on the material and eventually, it turned into a more comprehensive introduction to R. The book is a result of my passion for teaching R and my interest in the pedagogy of teaching programming. The pedagogical style is heavily inspired by that of the Carpentries lesson material, which is presented excellently in Greg Wilson’s Teaching Tech Together. However, in contrast to a typical Carpentries lessons, this book progresses faster and its treatment of R is more superficial. It provides a broader overview of R at the expense of depth. About the author I have worked with R and other languages in a research context for almost 10 years and I have made some humble contributions to the R ecosystem. I teach R as a certified instructor for The Carpentries, and I help maintain the Carpentries lesson material for the lesson Data Analysis and Visualization in R for Ecologists. I really enjoy teaching researchers to code and I especially like showing them the marvelous world of R. If you have any feedback or suggestions I’d be happy to hear from you! Contact me on Twitter, via email, or by raising an issue on the book’s Github repository. If you are a seasoned programmer, there may be more efficient ways to catch up on R than this book. I recommend the books R for Data Science and Advanced R. Both are available for free online.↩︎ "],["what-is-r.html", "What is R?", " What is R? You wouldn’t be reading this if you didn’t already have some idea what R is, but I think it will be useful to briefly discuss this anyways. R is a statistical computing and data analysis environment that is widely used in academia, industry, and the public sector.2 It is a free and open source implementation of the programming language S, which was created in the 1970s with interactive data analysis in mind. Here’s what that means: R is free and open source – R is owned and developed by the community of its users. This has led to a rich and continually evolving ecosystem of freely available extensions (packages) for R that cover many fields and applications. R is interactive – R works like a fancy pocket calculator that allows you to do calculations, explore data, and analyse data quickly and on the fly. You can execute short snippets of code individually and in any order and store and retrieve data in R’s memory as you go. This allows for a very flexible, interactive workflow that is especially well suited for data exploration and analysis.3 R is focused on data analysis – Right out of the box, R gives you a powerful tool belt for data analysis. More than in many other programming languages, data and statistics are at the core of R and there are built-in data structures and functions that make data analysis easier. Although R is a proper programming language4, its main focus is undoubtedly data analysis. So much so, that some people call R a domain specific programming language. Others say that R is an environment for interactive data analysis that has a programming language. In any case, R is a powerful one-stop-shop for the whole data analysis workflow: Data collection Data wrangling5 Data Visualization Modeling Communication In 2020, R even briefly climbed to the 8th place of the TIOBE index of in-demand programming languages (https://www.tiobe.com/tiobe-index/r/).↩︎ This workflow is not unique to R. Python, for example, offers similar functionality via the iPython (interactive Python) project.↩︎ Some people claim that you can use R for everything.↩︎ This part of the data analysis workflow involves data cleaning and transformation and is also known as data munging, or 80% of data science.↩︎ "],["why-not-r.html", "Why you should not learn R Learning R is a considerable time investment Free point and click alternatives Commercial software Other programming languages", " Why you should not learn R Before we continue, we have to get something out of the way: there are very good reasons not to learn R! I do not want to discourage you from learning R — personally, I think R is one of the greatest tool a researcher or data analyst can have — but I also understand that it’s not for everyone and it is important to consider the cost of learning R and the possible alternatives. Figure 0.1: Regardless of what R enthusiasts like me will tell you, R is not the solution to every problem. Learning R is a considerable time investment First of all, R can be challenging to learn. Learning any programming language requires continuous practice, and depending on your previous experience and your ability to think like a computer, it will take months or years before you can work efficiently in R. Getting there can—at times—be frustrating. Even if you already know another programming language, R may be difficult to learn, because it can be a little weird.6 The invested time and cognitive energy may never pay off if you only do a small analysis every once in a while or if your current workflow is already very efficient. Free point and click alternatives There are free alternatives to R that do not require coding. Some of them excel at a particular part of the data analysis workflow, for example, OpenRefine and DataWrangler for data wrangling, and RAWgraphs, Flourish, DataWrapper, and Tableau Public for data visualization. Others offer comprehensive functionality which rivals that of costly software like SPSS. Jamovi and JASP, for example, are graphical user interfaces that are built on top of R and allow you to utilize much of R’s power without writing any code. Figure 0.2: There are plenty of fish in the open source sea and Jamovi is a particularly tasty one. Commercial software There are many well-rounded commercial software packages for data analysis, such as SPSS, SAS, Stata, MPlus, and MATLAB. Chances are, you are already familiar with at least one of them. Some commercial tools are the gold standard for certain types of analyses and the exact same methods may not be available in R.7 Commercial software often does a better job than R at guiding you through the jungle of statistical tests and models, they provide customer support and there is normally a single, well-documented way to solve a certain type of problem. In contrast, R often offers a multitude of ways to reach the same goal. While this allows you to choose the tools that suit your needs, this choice can be difficult. Consequently, R requires a more thorough understanding of what your are trying to achieve. Figure 0.3: Welcome to R! Here’s how you quit… Other programming languages Point-and-click graphical user interface such as SPSS or Jamovi only work well if you stay within the limits that their developers had in mind. Programming gives you much more versatility and flexibility,8 which makes it a useful skill to have under your belt, even if you end up not using it much. However, R is by no means the only programming language you could choose to learn. For example, Python is worth a look if you want to learn a language that is more universally useful than R while still being excellent for data analysis, Julia is a great choice If you need a language that is as focused on interactive scientific computing as R, but more modern and a lot faster Javascript, the language of the web, is great if you are interested in building interactive data visualizations, but it is also shaping up to become a serious contender in the data analysis space.9 For examples of R’s weirdness, I recommend John Cook’s talk The R Language The Good The Bad &amp; The Ugly and Roger Peng’s talk Teaching R to New Users: From tapply to Tidyverse.↩︎ For example, handling missing data with Maximum Likelihood in MPlus is not possible in the equivalent R package, {MClust}.↩︎ In computer science this is referred to as the expressive power of a programming language↩︎ For example, see https://js4ds.org/↩︎ "],["the-road-ahead.html", "The road ahead Overview Conventions", " The road ahead Now that we know what R is and we have discussed some good alternatives, we will have a look at what speaks for learning R. There are many good reasons to learn R! In the next section of the book I will present ten of them, and we will also get hands-on with R. This is a very superficial introduction and we will skip over some of the details for the sake of showing you the whole spectrum of what R has to offer and providing you with knowledge that is practically useful in as little time as possible. We will use modern R with RStudio and the Tidyverse (more about that later). This will help us to focus on data analysis quickly, without worrying to much about some of the more technical aspects of programming. Overview Here are the 10 things we will look at: 1. Free and open source We will learn about free and open source software and why it is great. 2. Easy to get started We will install R and RStudio, setup an RStudio project, and start interacting with R in the console and by writing our first script. 3. A flexible language that grows with you We will get to know the fundamental data types and data structures of R. 4. Well-documented We will learn how to get help in R. 5. Expandable We will learn how to add additional functions to R by installing packages and we will learn how to load data into R. 6. Powerful data wrangling functions We will see how to transform data to prepare it for data analysis, join data. 7. Powerful data visualization functions We will make a complex statistical graph with just one line of code. 8. Powerful statistical methods We will run a statistical model with just one line of code. 9. Encourages reproducible research We will make our analysis reproducible. 10. An awesome community We will talk about where to find other R users and how to continue learning. Conventions In the text, names of R packages will look like this: {r tidyverse}. R code will appear inline like this print(\"Hello R!\") or in a box, followed by its output like this: print(&quot;Hello R!&quot;) [1] &quot;Hello R!&quot; There are three different types of callout boxes: At the beginning of each chapter, I will list the things we are going to do and learn. You can use these to check your prior knowledge and decide to skip chapters that won’t provide any new insights for you. This is an info box. It expands on a learning point and gives you details that may not be essential but could help you to see the connections between concepts. It is ok to skip these entirely if they are not helping. Exercise 0.1 This is a challenge. Do these to deepen your understanding. To reveal the solution in the box below, hover over it (on a computer) or click it (on mobile). print(&quot;This is the solution&quot;) "],["r-is-free-and-open-source.html", "Reason 1 R is free and open source 1.1 Is R reliable?", " Reason 1 R is free and open source What is free and open source software (FOSS)? Is free and open source software reliable? A great reason for choosing R over commercial software packages is that it is is free and open source software (FOSS). This means that nobody can ever own any exclusive rights to R. Anyone can obtain a copy of R for free and modify it however they like. The license under which R is published guarantees that it will stay like that forever. Being free means that there are no software license fees or purchasing costs. This means lower cost and less bureaucracy! It means that you can use R everywhere, and you can use any version of it at any time. This is great for collaboration, sharing, and reproducibility. Being open source means that nobody can decide to stop the development of R. Moreover, if anything is missing, R users can create it themselves, and — as we will see later — they do! There are tens of thousands of extensions (packages) for R that were created by the R community and are free for everyone to use. Finally, being free an open source means that you can simply give R a spin and see if it’s for you — no strings attached! 1.1 Is R reliable? Make no mistake: Free and open source does not mean unprofessional! The R project is very stable, and there is a core team of computer scientists and statisticians guiding its development. While a lot of the improvements to R are contributed by volunteers, the project does receive financial support directly from companies such as RStudio and rOpenSci, who employ developers to improve R, and indirectly through people who contribute to the R project as part of their jobs (e.g., research software engineers, statisticians, data scientists). There are also peer-reviewed journals such as the Journal of Statistical Software and the R project’s own R Journal, which academics can use to get credit for working on R-related things. It’s also common to see papers in other journals introducing new statistical methods alongside an implementation in R. "],["its-easy-to-get-started.html", "Reason 2 It’s easy to get started 2.1 Why RStudio? 2.2 Create a new RStudio project 2.3 Using R as a calculator 2.4 Create a script", " Reason 2 It’s easy to get started How to install R an RStudio Creating a project in RStudio Running commands in the R console and from a script file R’s basic operators Getting R to run on your computer is usually a relatively smooth experience10: Download and install the latest version of R (https://r-project.org/) and RStudio (https://rstudio.com/products/rstudio) for your operating system. If you already have either program installed on your computer, there is no need to uninstall the old versions beforehand. If you cannot or do not want to install anything on your machine, you can instead make an account at RStudio Cloud (https://rstudio.cloud/) and use R and RStudio in the browser. The free tier of RStudio Cloud only allows you to use it for a few hours per month, but for the purpose of working through this book that should be fine. That’s it! Everything else you need can be set up from within RStudio. Well, actually… If you are using Windows, you might eventually also have to install RTools (https://cran.r-project.org/bin/windows/Rtools/). RTools provides additional tools, such as a C/C++ compiler, that you will need for things like Bayesian statistics. For reproducible research, you should also install Git (https://git-scm.com/), a version control system which we will briefly talk about later. For now, you do not have to worry about these things, because you can always do them later. Exercise 2.1 Use one of the methods suggested above to get access to R and RStudio so you can follow along for the rest of the book. 2.1 Why RStudio? You might be wondering what RStudio is and why we need it. RStudio is a popular all-in-one user interface (Integrated Development Environment, IDE) for R. It provides many conveniences that make working with R a lot easier. To use an analogy: If R were a horse, RStudio would be a saddle to sit in. You don’t need it, but it makes things more comfortable. There are some alternatives to RStudio, but R’s own GUI is not really one of them: Figure 2.1: R’s own GUI — The 90s called, they want their user interface back. 2.2 Create a new RStudio project Alright cowboy, let’s saddle that horse! The first step you should do whenever you start a new data analysis project with RStudio is to create a new project folder. This is the first step towards reproducibility: All of your project’s data and files will be stored in this folder. If you ever move this folder to a new location or share it with someone else, all of the files will move along with it and nothing will break. Another benefit of using projects is that it helps you keep your work organized. It will be much easier for you to switch between projects or get back to a project you haven’t touched in a while. Exercise 2.2 Open RStudio, go to File ▸ New Project... and create a new RStudio project in an empty folder. Leave Use version control and Use renv unchecked for now — we will get back to those later. Now that we have our project set up, let’s have a look around RStudio. The many panels and tabs in RStudio may be overwhelming at first, but I promise this gets better over time, and most of them are actually really helpful. The console, for example, allows you to directly interact with R. Figure 2.2: RStudio’s user interface with the four panels 2.3 Using R as a calculator In the console you can type commands and when you press Enter, R will try to interpret them. You can use ↑ and ↓ to cycle through previous commands and Ctrl/Cmd + ↑ to search through previous commands. Let’s get familiar with the console by trying some of R’s mathematical operators. R has all the operators that you would expect to find in a pocket calculator: Arithmetic + - * / ^ Modular arithmetic %% %/% Relational &lt; &gt; &lt;= &gt;= == != Logical &amp;&amp; || ! | &amp; Parentheses for modifying precedence (1 + 2) * 10 It also has all the functions you would find in a calculator. Functions are written as the function name followed by the function’s argument in parentheses. For example, for calculating the square root of 2, use sqrt(2). Exercise 2.3 In the console, try out some of R’s operators and see what happens. For example, What does 1 != 1.0 do? What happens if you run an incomplete command like 1 * What happens if you run a command that does not make sense, like 1*/ 3 R checks whether the argument on the left side (1) is not equal to the argument on the right (1.0). It returns FALSE because to R these two numbers are identical. R waits for you to finish the command. Press Esc to terminate the incomplete command. R throws an error message and tries to tell you what went wrong. If you are working with R, you will have to get used to getting lots of error messages. Figure 2.3: Don’t worry – you can’t hurt R, it has been through this before… 2.4 Create a script The console is useful for running quick throw-away commands, and sometimes that’s all you need. However, code that you want to keep should be stored in a script file. R scripts allow a flexible console-like workflow because you can run individual sections or lines of code in any order. We will use a special type of script, called an RMarkdown Notebook. RMarkdown is a format that allows you to mix code and the output it generates with text. The text can be formatted with a special syntax to create headers, footnotes, links, and more. This allows you to keep your notes and your code together and is great for writing reproducible documents.11 Exercise 2.4 Go to File ▸ New File ▸ R Notebook to create a new RMarkdown Notebook and save it in your project’s working directory as analysis.Rmd. Note that the file has appeared in RStudio’s Files tab, which shows you all the files in your project folder. The new notebook already contains some example content. You can see that there is R code that is written inside special blocks, called code chunks. You can create new code chunks with the green button on the top right of the script panel or with the keyboard shortcut Ctrl/Cmd + Option/Alt + I You can run an entire code chunk by clicking the green arrow on the right of the chunk. You can also run individual lines or sections of code by using Ctrl/Cmd + Enter or the buttons on the top right of the script panel. Exercise 2.5 Add a new code chunk to your R Markdown Notebook in which you calculate the square of 2021 as well as the square root of 1764. Then run the chunk. The code chunk in analysis.Rmd should look like this. ```{r} 2021^2 sqrt(1764) ``` When you run the chunk, the output should be [1] 4084441 [1] 42 It can get a little hairy if you are working on a machine with restricted permissions, for example a computer issued to you by your employer. If you are in a situation like this, I will ask you to kindly contact your IT department to sort it out.↩︎ This entire book was written with RMarkdown.↩︎ "],["a-flexible-programming-language.html", "Reason 3 A flexible programming language 3.1 Data Types 3.2 Assignment 3.3 Comments 3.4 Vectors 3.5 Data Frames 3.6 Other Data Structures", " Reason 3 A flexible programming language The core data types are numerical, logical, and character To assign data to variables use &lt;- Write comments with # The most important data structures are vectors and data frames Vectors store a multitude of the same data type in a particular order Data frames are tables with data organized in rows and columns R is a powerful and complex programming language that supports many different programming paradigms. However, to get started with data analysis, its enough to understand R’s basic data types (numeric, logical, and character) and two data structures: vectors and data frames. These are made for data manipulation and analysis, and along with the many convenience functions that R provides, they allow you to focus on data analysis without worrying about thing that are fundamental in other languages like control flow (loops and if-else-statements). As you become more familiar with R, you can add those to your repertoire, too, and utilize R’s full power and flexibility. 3.1 Data Types The data type of a piece of data determines what operations you can perform with it. The bread and butter of data types in R are numeric, logical, and character. Numerical Numerical data can be integer, decimal12, or complex, but usually the difference does not matter. Sometimes, R might unexpectedly hit you with a number in scientific notation, e.g., 1e+23. To the uninitiated, these can look cryptic and a bit scary. But don’t worry! It’s just a very large or very small number that is written in a more compact form and you can change disable this if you like! 23 + 0.45 + 1e2 + 6i Logical Logical data (also known as Boolean data) can be either TRUE or FALSE (or their shorthands, T and F). These are often used to represent binary categorical variables, as function arguments, or as intermediate steps when selecting and filtering data. (TRUE || FALSE) != (F == T) Character Also known as strings. Almost anything you type becomes a character string if you surround it with \"\" or ''. &quot;Hello World!&quot; 3.2 Assignment To assign values to variables13, you can use &lt;-. Use the keyboard shortcut Alt+- to save yourself some hand gymnastics. Once assigned, you can use a variable’s name to represent its content in other operations. Typing a variable name by itself will print the variable’s content. a &lt;- 1 b &lt;- 9 c &lt;- a + b c [1] 10 Note how newly created variables appear in the environment panel in RStudio. When you are working with R, you are working in a session. The session provides an environment in which data is stored, and the variable name allows you to retrieve the data again. Unless you explicitly delete the variable or end the session, the data will be around for you to use it. There are some rules for variables names: They must start with a letter and contain only the letters of the English alphabet, numbers, underscores _, hyphens -, and dots ..14 For long variable names, it is recommended to use “snake case”, which looks like this: my_firssst_variable 🐍. Also note that R is case-sensitive. Exercise 3.1 What would be the result of running the code below? Think about it first and then run it to check your answer. a &lt;- 10 a + b # What will be the result of a + b? c # What has happened to c? C # Why is this not working? Many other programming languages use = to assign values to variables. You can, for the most part, also use = for assignment in R — just be aware that it will let everyone now that you are not a true believer. You can also use -&gt; to assign from left to right. This can it come in handy when you are messing around in the console, but it may not be a good idea to use it too much in your scrips, because it can make your code harder to read: &quot;Never look back!&quot; -&gt; x Finally, there’s &lt;&lt;-, which allows assignment to variables in an enclosing environment. This can be useful if you need to update global variables from within a function. However, this is far beyond the scope of this intro, and chances are you will never encounter a &lt;&lt;- in the wild. You can read more about R’s assignment operators here. 3.3 Comments As you can see in the example above, you can use # to leave comments in your script. Learn to write good comments and write comments gratuitously – your collaborators and future self will thank you for it! 3.4 Vectors In computer programming, data structures are a way to organize and process particular types of data efficiently. When working with data in R, you will encounter two important data structures: vectors and data frames. Vectors are made for storing values of the same data type (numerical, character, logical, …) in a particular order. To create a vector, you can use the “combine” function, c(). There are also the : and seq() functions, that can help you create a vector that contains a sequence of numbers: c(1,2,3,4) # create a vector manually 0:4 # a vector of all integer numbers from 0 to 4 4:0 # it also works backwards seq(0, 2, 0.5) # numbers 1.0 to 2.0 in 0.5 increments [1] 1 2 3 4 [1] 0 1 2 3 4 [1] 4 3 2 1 0 [1] 0.0 0.5 1.0 1.5 2.0 R is really good at working with vectors! See how easy it is to multiply all numbers by a scalar, get the mean, or sum all elements — all without using a loop or a temporary variable: x &lt;- c(1,2,3,4) # Create vector and assign to variable `x` x * 10 mean(x) sum(x) [1] 10 20 30 40 [1] 2.5 [1] 10 You can access specific positions of a vector using square brackets. Use : within brackets to access a range of indices. In R, indices start at 1, that is, index 1 will return the first element of the vector. x[1] [1] 1 x[2:3] [1] 2 3 You can also use a vector of indices to index into another vector in order to select specific elements x[c(1,3)] [1] 1 3 You can also use the bracket syntax to replace individual elements: x[2:3] &lt;- 0 # replace 2nd and 3rd element with 0 x[2:3] &lt;- c(7,8) # replace 2nd and 3rd element with 7 and 8, respectively Values in a vector can be named. This comes in handy, for example, if you need a simple key-value store: fav_food &lt;- c( Garfield = &quot;Lasagna&quot;, Popeye = &quot;Spinach&quot;, Obelix = &quot;Roast Wild Boar&quot; ) fav_food[&quot;Popeye&quot;] Popeye &quot;Spinach&quot; Implicit Coercion Vectors can only contain a single data type. If you are trying to mix data types, R will quietly (without throwing an error) coerce (that is, convert) all data types to a data type that can represent all elements. This coercion follows a certain hierarchy: logical becomes numerical (FALSE = 0 and TRUE = 1) numerical becomes character The coercion only goes in one direction. For example, character strings that happen to contain numbers will nevertheless be treated as characters. Consider these examples: c(FALSE, TRUE, 2, 3) # logical becomes numerical [1] 0 1 2 3 c(1, 2, &quot;3&quot;) # numerical becomes character [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; This also happens if you update a vector after it has already been created. x &lt;- 1:3 x[1] &lt;- TRUE # this logical will become numerical x [1] 1 2 3 Vectors cannot contain other vectors, so nested vectors automatically get unnested, and as they get unnested, the elements will be coerced to a common data type: c(1, c(2,3,4)) c(c(TRUE, 0), c(TRUE, &quot;0&quot;)) # logical and numerical become character [1] 1 2 3 4 [1] &quot;1&quot; &quot;0&quot; &quot;TRUE&quot; &quot;0&quot; This behavior can sometimes be used for good, but in general it’s best to avoid it. Make coercion explicit. For example, if you want to convert a character representation of a number to numeric, do so with the as.numeric() function. For more complex applications consider static typing with https://github.com/moodymudskipper/typed. If you really need to store a sequence of mixed data types, you will have to use another data structure called list. 3.5 Data Frames Usually, your research data will be more complex than just a single sequence of values. For this, R has data frames. Data frames are two-dimensional like a spreadsheet – with rows usually containing different observations and columns usually containing different variables. Rows and columns of a data frame can be named, and while row names seem to have fallen out of fashion, it is good practice to give the columns of your data frames names that are easy to remember and easy to type. You can make your own data frame by hand, by putting together vectors like this: cool_numbers &lt;- data.frame( &quot;number&quot; = c(1,13,23,42), &quot;isPrime&quot; = c(FALSE, TRUE, TRUE, FALSE), &quot;oneTwo&quot; = c(1, 2) ) cool_numbers number isPrime oneTwo 1 1 FALSE 1 2 13 TRUE 2 3 23 TRUE 1 4 42 FALSE 2 Note how the vector c(1,2) in the oneTwo column will get recycled to match the length of the other two columns. This works, as long as the total length is a multiple of the shorter vector’s length. A quick way to access a single column of a data frame is with the $ operator. cool_numbers$number [1] 1 13 23 42 Did you notice that columns in a data frame are vectors? This means that everything that can be done with a vector can be done with a data frame column! In fact, all “atomic” data types in R (numeric, characters, logical) are always stored as vectors – even a single number is actually a numerical vector of length one! This is a really powerful idea and the source of much of R’s strength! Exercise 3.2 Make a new data frame my_cool_numbers with a column a that contains all numbers from 1 to 100 and column b that contains your favorite number 100 times. my_cool_numbers &lt;- data.frame( &quot;a&quot; = 1:100, &quot;b&quot; = 42 ) Since data frame columns are vectors, we can use the same operations on them. calculate the standard deviation of all numbers in column a in our my_cool_numbers data frame! Use the RStudio help to find the right function for it. sd(my_cool_numbers$a) As for vectors, R comes out of the box with many more commands to create and modify data frames, select columns, and filter rows. You will eventually need to get familiar with these. However, in this short introduction we will skip these in favor of the more streamlined and beginner-friendly functions from the Tidyverse – more about that later. 3.6 Other Data Structures R has a couple of other data structures that you will eventually encounter. I don’t want to dwell on them for too long, because they will not play a role in the rest this book. If you are interested you can read more here. Additional R data structures include … Tibble – You may see the word Tibble pop up occasionally in the examples in this book. A Tibble is a data structure is a modern implementation of data frames. Tibbles are backwards-compatible with data frames and for the purpose of this book you can think of them as interchangeable. Factor – Factors are numerical vectors that can take a fixed set of values (levels), whereby each level can be assigned a label. The levels may be ordered or unordered. If this reminds you of categorical and ordinal variables you are absolutely right – that’s where they are used most often. While factors can be quite useful, they are also a point of confusion for many R novices. List – Lists are similar to vectors, but they can contain a mix of data types and data structures, including other lists. Object – Objects can be used to organize functionality. For instance, a statistical model may be an object that has various attributes and associated functions. R even has three types of objects: R6, S3, and S4. Matrix – Not to be confused with data frames. If you are implementing statistical methods yourself, you may want to make use of R’s matrix algebra functions. Otherwise, you likely won’t often have to work with matrices directly. Environment – Do you remember when I said that your R session provides an environment in which data is stored? It turns out that environments are yet another data structure in R. An environment is a data structure that contains other named R data structures. Understanding environments is central to a deep understanding of R, but as a beginner it’s nothing you need to worry about. Decimal numbers are also called floating point numbers or “float” for short. Note that R uses periods . to designate the decimal places, not commas , as in some countries.↩︎ In official R lingo you are assigning values to objects, but people who have experience with other programming languages sometimes find this term confusing. Therefore, I will use the word variable in this book.↩︎ Unlike in other programming languages, dots have no special function or meaning and can be used in variable names.↩︎ "],["fantastic-documentation.html", "Reason 4 Fantastic documentation 4.1 Accessing function documentation 4.2 Auto-completion 4.3 Cheat sheets 4.4 Finding help online", " Reason 4 Fantastic documentation Accessing the function documentation in RStudio Finding help in cheat sheets and by searching online Utilizing auto completion while writing code Are you wondering how you should ever remember all of the different R commands and how to use them? Fear not! R and RStudio have a number of ways to make your life easier. 4.1 Accessing function documentation The Help panel in RStudio gives you direct access to the help files of all R functions that you have installed. You can search in the search box there, or type ?mysterious_function in the console. However, my favorite way to assess the help is to put the cursor on the function name and press F1 (similarly, you can use F2 to access the source code for anything – It is open source, after all!). Having documentation easily available right in RStudio helps to learn the basics quickly and stay in the flow while you code. It’s also worth mentioning that R’s Function documentation, package vignettes and package websites are usually well-written and comprehensive. Exercise 4.1 Look at the help file for the mean() function, see what other arguments the function accepts. How would you calculate a trimmed mean? To get the 10% trimmed mean of a numerical vector x, you can run mean(x, trim = 0.1). This will remove 10% of the lowest observations and 10% of the highest observations before calculating the mean. For example: mean(c(-1000, 2, 2, 2, 2, 2, 2, 2, 2, 20, 1000), trim = .1) [1] 4 4.2 Auto-completion If you can’t quite remember the function name, RStudio will try to assist you with its excellent fuzzy auto-completion that suggests functions while you type. Use ↑, ↓, and ↹ to select one of the choices. 4.3 Cheat sheets There are excellent cheatsheets for popular packages available in the RStudio menu (Help &gt; Cheatsheets &gt; ...) Exercise 4.2 Have a look at the cheat sheet for the RStudio IDE and find out how to search and replace code in RStudio. 4.4 Finding help online If you ever run into a problem or an error message that you can’t figure out yourself Google your problem. SOmeone else probably ran into a similar thing before. You can find also lots of blogs with tutorials written by other R users. R Bloggers aggregates many of them. Also check out the searchable database of “R Posts you might have missed” Stack Overflow, RStudio Community, or the R mailing are full of people asking and answering questions about R, and you are welcome to ask your questions there. "],["expandability.html", "Reason 5 Expandability 5.1 Introducing the Tidyverse 5.2 Installing packages 5.3 Loading data 5.4 Inspecting the data 5.5 Saving data to disk", " Reason 5 Expandability R packages are collections of R code written by others The Tidyverse is a collection of packages that share a common user-centric design philosophy How to install and load an R package? Loading data from a text file with read_csv() Saving a data frame to the disk with write_csv() Getting a high-level overview of a data frame with head(), view() and {skimr} R is popular among data analysts, data scientists, researchers, and statisticians. As a result, R gives you access to a vast amount of amazing packages written by expert statisticians and programmers around the world. An R package is a collection of R code that has been bundled up so that it can be easily used by others. The full power of R unfolds when you tap into this vast ecosystem of packages. There are tens of thousands of packages to make your life easier! There’s an R package for almost everything! See for yourself at rdrr.io or Metacran. Packages on CRAN, BioConductor, and Neuroconductor are peer-reviewed and often written by domain experts. Many more packages are available on Github. And if there’s ever anything missing you can build it yourself – together with others across the globe. It’s fun and you will learn a lot! By the way: R can also integrate with Python, C, and other languages and interface with other software, such as MPLUS. You can also write your own R package. The R Packages book provides a deep dive into writing and publishing R packages. 5.1 Introducing the Tidyverse The Tidyverse (Wickham et al. 2019) is a set of R packages that share a common design philosophy. It aims to provide user-friendly functions for common data-tasks and tries to iron out some of the idiosyncrasies of Base R. The functions in the Tidyverse have a consistent interface and easy-to-remember names. The Tidy Data that gives the Tidyverse its name has tabular shape, with one observation per row one variable per column a single-level header variable names that are easy to type and easy to remember The core idea is this: Once the data is in tidy format, all the Tidyverse functions can be used seamlessly. A special operator, the pipe %&gt;%, glues all the functions together, so that the steps of the analysis can be read from top to bottom, like a recipe (see below). The Tidyverse is a relatively recent addition to the R package ecosystem but the design philosophy has struck a chord with the R developer community and many packages are now following the same principles. As a result, the overall data analysis workflow in R has become more streamlined and integrated. Nevertheless, some people prefer base R or other alternatives to the Tidyverse, such as the {data.table} package. Moreover, many older packages will never change to a “tidy” design. This leads to a bit of a schism in the R package ecosystem. Eventually, you will have to learn about these alternatives as well. However, you can get a long way by just focusing on the Tidyverse. 5.2 Installing packages For the examples in this book we will use a table with information about climbing expeditions in the Himalaya that was provided by Tidy Tuesday. Often you will read data from external sources and the first step is to turn it into something that R can work with, usually a data frame. In this case, the data is provided as a CSV file. CSV stands for comma separated values and is a popular plain text format for sharing tabular data across the internet. To read the CSV file and turn it into an R data frame we will use the read_csv() function. To use this function, we first have to install and load the {tidyverse} package.15 You can install the package from R’s central package repository CRAN. The install.packages() function looks for a package of a given name on CRAN, and, if it finds it, copies it to a special library directory on your computer. The library() function loads a package that you have installed, so that all of its functions become available for you to use in your current R session. The next time you start RStudio, you will not have to reinstall the package (it is now on your computer), but you will have to load it again. install.packages(&quot;tidyverse&quot;) library(tidyverse) library vs. package The distinction between library and package can be confusing. It might help to imagine that you are using install.packages()to add a package to your system’s library of packages using library() to check out a package from your library, so that you can use it in your current R session. Note also that the quotation marks around the package name in install.packages() are required, because this is essentially a search term that will be used to find the package on CRAN. The quotation marks in library() are optional, because the package exists as an object in your library, from where you can call it by its name, just like any other variable. 5.3 Loading data Now that we have the {tidyverse} package installed and loaded, we can use the read_csv() function to load the data straight from the web into an R data frame in our R session. peaks &lt;- read_csv(&quot;https://raw.githubusercontent.com/teebusch/r-introduction/master/data/peaks.csv&quot;) Rows: 468 Columns: 8 ── Column specification ──────────────────────────────────────────────────────── Delimiter: &quot;,&quot; chr (6): peak_id, peak_name, peak_alternative_name, climbing_status, first_a... dbl (2): height_metres, first_ascent_year ℹ Use `spec()` to retrieve the full column specification for this data. ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. 5.4 Inspecting the data When we load the data, R shows us the names of the columns in the data set and the type of each column. We can also have a look at the first few rows with the head() function. head(peaks) # A tibble: 6 x 8 peak_id peak_name peak_alternative_name height_metres climbing_status &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; 1 AMAD Ama Dablam Amai Dablang 6814 Climbed 2 AMPG Amphu Gyabjen &lt;NA&gt; 5630 Climbed 3 ANN1 Annapurna I &lt;NA&gt; 8091 Climbed 4 ANN2 Annapurna II &lt;NA&gt; 7937 Climbed 5 ANN3 Annapurna III &lt;NA&gt; 7555 Climbed 6 ANN4 Annapurna IV &lt;NA&gt; 7525 Climbed # … with 3 more variables: first_ascent_year &lt;dbl&gt;, first_ascent_country &lt;chr&gt;, # first_ascent_expedition_id &lt;chr&gt; You can get a more traditional spreadsheet-like view of the complete data frame by clicking its name in the Environment panel or running the command view(peaks). To better understand our data, let’s get some summary statistics. The {skimr} package (Waring et al. 2021) provides a really nice function for this. Exercise 5.1 Install and load the {skimr} package from CRAN. install.packages(&quot;skimr&quot;) library(skimr) Now we can “skim” our data: skim(peaks) Table 5.1: Data summary Name peaks Number of rows 468 Number of columns 8 _______________________ Column type frequency: character 6 numeric 2 ________________________ Group variables None Variable type: character skim_variable n_missing complete_rate min max empty n_unique whitespace peak_id 0 1.00 4 4 0 468 0 peak_name 0 1.00 4 25 0 468 0 peak_alternative_name 223 0.52 5 49 0 242 0 climbing_status 0 1.00 7 9 0 2 0 first_ascent_country 132 0.72 2 44 0 77 0 first_ascent_expedition_id 135 0.71 9 9 0 332 0 Variable type: numeric skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist height_metres 0 1.00 6656.64 571.91 5407 6235.75 6559.5 6911 8850 ▂▇▃▁▁ first_ascent_year 132 0.72 1979.08 100.21 201 1963.00 1982.0 2008 2019 ▁▁▁▁▇ This summary tells us quite a lot about our data! For example, we can see that some peaks have not been successfully climbed until very recently, or not at all. There also appears to be an outlier in the first_ascent_year column that we’ll have to take care of – a peak that was successfully climbed in the year 201. The :: operator We only use one function from the {skimr} package, and we only use it this one time. In a case like this, you might want to use the function without loading the entire package. To do so, you can put :: between the package name and the function name. Thus, skimr::skim(peaks) is equivalent to library(skimr) skim(peaks) The :: is also often used to clarify (either to R or to the person reading the code) which package a function is coming from. This is particularly useful when there are functions with the same name in different packages. Another approach to solving this problem is the {conflicted} package (???). 5.5 Saving data to disk We loaded the data from the web straight into R. Thus so far, it only exists in the current R session, that is, in the computer’s working memory. To store a copy of the data on the hard drive, we can use the write_csv() function. It takes the variable and a file name. In more complex projects you should put your data files into a subfolder. Here, we will keep it simple and put everything in the top-level project folder. write_csv(peaks, &quot;peaks.csv&quot;) R can connect to many different sorts of data sources, such as databases, APIs, and websites). It can also read and write many different data formats – including data from software like SPSS, Stata, and SAS. The {rio} package (???) provides a unified interface for a whole range of data formats. Be careful when using Excel to store and share your data! Excel silently converts certain data. This can cause problems. In many cases it may be better to use CSV, JSON, Feather, or a database to store your data. Usually, packages are collections of functions. The {tidyverse} package (Wickham 2021) is a bit different, as it is actually a collection of other packages — a meta-package. When you load it, it loads the most popular packages from theTidyverse, such as {ggplot2}, {readr}, and {dplyr}. For example, the read_csv() function is from the {readr} package.↩︎ "],["data-wrangling-superpowers.html", "Reason 6 Data wrangling superpowers 6.1 Filtering and counting rows 6.2 The pipe operator %&gt;% 6.3 Create new columns with mutate() 6.4 Split-apply-combine with group_by() and summarize() 6.5 Joining data frames with left_join() 6.6 Other useful data wrangling functions", " Reason 6 Data wrangling superpowers … … The Tidyverse offers many convenience functions for common data manipulation tasks like splitting and merging columns, renaming, counting, sorting, and much more. At its core, are a handful of workhorse functions from the {dplyr} package for manipulating data frames: filter() – select rows (observations) select() – select variables (columns) mutate() – create new variables (columns) or change existing ones summarize() – aggregate rows, e.g, to calculate a column’s mean group_by() – split the data frame pivot_wider() and pivot_longer() – reshape the data 6.1 Filtering and counting rows Let’s do a simple data wrangling task using functions from the Tidyverse: Find all peaks that are higher than 7,000 meters and were climbed before 1980 Count which countries the climbers came from We can use the filter() function to select only the rows (observations) we want. Then we can use the count() function to count how many rows there are for each kind of first_ascent_country: before80_7k &lt;- filter(peaks, first_ascent_year &lt; 1980, height_metres &gt; 7000) count(before80_7k, first_ascent_country) # A tibble: 28 x 2 first_ascent_country n &lt;chr&gt; &lt;int&gt; 1 Austria 2 2 Austria, Nepal 1 3 Austria, USA, Nepal 1 4 Austria, W Germany 1 5 France 3 6 France, Nepal 1 7 Germany, Austria 1 8 Germany, Nepal 1 9 India 1 10 Japan 7 # … with 18 more rows 6.2 The pipe operator %&gt;% Above, we stored the result of the first function in an intermediate variables and then gave it to the second. There’s another way to chain functions that is often more convenient and readable: Use the pipe operator %&gt;% to pass data from one function to the next. You can read %&gt;% as “…and then…”. Use the keyboard shortcut Ctrl + Shift + M to make it. peaks %&gt;% filter(first_ascent_year &lt; 1980, height_metres &gt; 7000) %&gt;% count(first_ascent_country, sort = TRUE) %&gt;% filter(n &gt; 3) # A tibble: 4 x 2 first_ascent_country n &lt;chr&gt; &lt;int&gt; 1 Japan, Nepal 14 2 Japan 7 3 Poland 4 4 UK, Nepal 4 # ... the pipe can continue. Here, we filter all peaks that # were climbed more than 3 times Did you notice that the first argument of all functions (the data frame you want to operate on) has disappeared? The pipe operator fills that one in automatically. Figure 6.1: Indubitably, sir! 6.3 Create new columns with mutate() peaks %&gt;% select(peak_name, climbing_status, first_ascent_year, first_ascent_country) %&gt;% mutate(climbed_before80 = first_ascent_year &lt; 1980) # A tibble: 468 x 5 peak_name climbing_status first_ascent_ye… first_ascent_co… climbed_before80 &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; 1 Ama Dablam Climbed 1961 New Zealand, US… TRUE 2 Amphu Gya… Climbed 1953 UK TRUE 3 Annapurna… Climbed 1950 France TRUE 4 Annapurna… Climbed 1960 UK, Nepal TRUE 5 Annapurna… Climbed 1961 India TRUE 6 Annapurna… Climbed 1955 W Germany TRUE 7 Annapurna… Climbed 1974 Spain TRUE 8 Annapurna… Climbed 1980 W Germany FALSE 9 Annapurna… Climbed 1964 Japan, Nepal TRUE 10 Api Main Climbed 1960 Japan, Nepal TRUE # … with 458 more rows 6.4 Split-apply-combine with group_by() and summarize() Use group_by() and summarize() together for powerful split-apply-combine operations: peaks %&gt;% filter(first_ascent_year &gt; 201) %&gt;% group_by(first_ascent_country) %&gt;% summarize(min_ascent = min(first_ascent_year, na.rm = TRUE)) %&gt;% arrange(min_ascent) # A tibble: 77 x 2 first_ascent_country min_ascent &lt;chr&gt; &lt;dbl&gt; 1 UK 1909 2 Austria 1930 3 Austria, UK 1930 4 Germany, Austria 1930 5 Germany, Nepal 1930 6 Switzerland, Germany 1939 7 Switzerland 1949 8 Switzerland, Nepal 1949 9 UK, Nepal 1949 10 France 1950 # … with 67 more rows Dealing with NA (missing values) In R, there is a special value for missing data, NA. This is not a data type. That is, a value can be, e.g., numeric and missing (NA) at the same time, and a numeric vector can contain a mix of numbers and NA. Functions that operate on vectors, like mean() or min() do not like to make assumptions about missing values, so when the input contains an NA, the result will automatically also be NA. This makes sense, because the unknown number may well be a value would totally change the mean or the minimum. It is possible (and often necessary) to circumvent this “safety measure” by setting the function argument na.rm = TRUE. This will treat the vector as if the missing values did not exist. 6.5 Joining data frames with left_join() #... 6.6 Other useful data wrangling functions There are many other useful functions in the Tidyverse. # ... "],["powerful-data-visualization.html", "Reason 7 Powerful data visualization 7.1 The fastest way to make a plot", " Reason 7 Powerful data visualization … … Perhaps the most popular package for data visualization in R is {ggplot2}. It comes with the {tidyverse} package, but there are many other packages that extend the functionality of {ggplot2}, such as {ggforce} or {gganimate}. These packages share a unifying design principle, the Grammar of Graphics (hence the “gg”). At its core, the Grammar of Graphics is about mapping attributes of your data (such as the magnitude of a number or the category that an observation belongs to) to aesthetics of geometric objects (such as position and size of a point or the height and color of a bar), potentially after applying statistical transformations like counting or averaging observations. This foundation turns out to be extremely versatile and allows You can see examples of what is possible with {ggplot2} in the submissions for Tidy Tuesday – a weekly exercise for practicing data visualisation. Some people even use {ggplot2} to make generative Art! Mastering {ggplot2} can take a while. However, there are some websites that provide example code for different types of charts. The R graph gallery is particularly comprehensive. There are also packages like {esquisse} that provide you with an intuitive graphical user interface for using {ggplot2}. The {ggplot2} package itself is mainly limited to static graphs. However, packages like {plotly}, and {shiny} allow you to make interactive visualizations and dashboards with relative ease. Integration with JavaScript (e.g., D3.js) - the sky is the limit! See ggplot2 – Elegant graphics for data analysis for a deep dive into {ggplot2} 7.1 The fastest way to make a plot In a short intro like this, there is not enough time to dive deeply into {ggplot2}. # ... "],["powerful-statistical-methods-at-your-fingertips.html", "Reason 8 Powerful statistical methods at your fingertips 8.1 Statistical modeling", " Reason 8 Powerful statistical methods at your fingertips … … Many simple stats are built into R (glm(), chisq.test() and many more). No additional packages needed! For more advanced analyses there are often multiple packages. Best to ask a domain expert what they use (or Google). Here are just a few examples: GAM, HLM, Mixture Models… SEM with {lavaan} Robust stats with {WRS2} Time series with {forecast} {zoo}, {xts} Bayesian Statistics with {brms}, {rstanarm}, {rstan} Text mining with {tidytext} Machine learning with {tidymodels} Network analysis with {tidygraph} or {igraph} Meta analysis with {metafor} and {rmeta} Introduction to Statistical Learning – A classic introduction to machine learning using R. {tidymodels} – package for a more modern machine learning toolbelt in R There are too many things to mention. The CRAN task views can be a good start. Likewise, Introductory Statistics in Psychology using R 8.1 Statistical modeling t.test() lm() Let’s try something more advanced… # ... "],["reproducibility.html", "Reason 9 Reproducibility 9.1 Self-contained projects with RStudio 9.2 Reproducible reports with RMarkdown 9.3 Version control with Git 9.4 Make your development environment reproducible 9.5 More", " Reason 9 Reproducibility How to organize your project directory Turning an RMarkdown notebook into a shareable document. Using Git to track changes. Using {renv} snapshots to manage package versions. Other ways to improve reproducibility Workflows that are based on graphical user interfaces are difficult to reproduce! In contrast, when you code your analysis with R, all the steps are laid out in your script. Well-written code allows someone else to retrace everything you have done and to understand how you got from your data to your results. To ensure that your results are truly reproducible, you must take additional measures. You need to make sure that your code produces the same results on another computer and at a later point in time. Moreover you should provide enough documentation to allow others to understand the motivation behind your analysis. You may be thinking that nobody will care to reproduce your analysis. Even if this is true, it is quite possible that you will at some later point get back to it, and your future self will certainly be grateful for making their job as easy as possible. 9.1 Self-contained projects with RStudio You have already learned how to store your analysis as a self-contained RStudio project. This was the first step to reproducibility, because RStudio projects are portable and self-contained. In addition, you should get familiar with best practices for organizing and naming the files in your project folder. As a primer, I recommend reading Good Enough Practices for Scientific Computing (Wilson et al. 2017). A few of the key points are: Store your data in a data/ directory. Keep your raw data as raw as possible. … … 9.2 Reproducible reports with RMarkdown Another tool for reproducible analyses that we have already introduced is RMarkdown. As you know, an RMarkdown document lets you mix text, R code, and the output of that R code. Now here is something amazing about RMarkdown: With the click of a button, you can turn an RMarkdown document into something that you can share with others, even if they do not have R! You can use this to make: reports papers with {papaja}, {rticles} books with {bookdown} (such as this one) websites, blogs with {blogdown}, {hugodown}, {distill} slides with {xaringan}, (also check out {xaringanthemer}) teaching with {learnR} Interface with Microsoft Office - Excel, Word, PowerPoint with {officeR} HTML is probably the most convenient and easy to use output format. If you want to use PDF or Word, you will have to worry about page sizes and page breaks. It’s best to avoid this until later in the process. For PDF in particular, you will also have to install a \\(\\LaTeX\\) distribution. I recommend {tinytex}. And if the data changes or a journal reviewer asks you to exclude a subject? Update the code and click the button again — all the figures and stats update! No more copy and paste! So how do we do it? # ... OK, but it still looks rather …. computerish. How do I make something that a normal person would want to read, or a journal would be willing to accept? As so often n R, there are packages that can help you with that. Packages to make pretty APA tables for models, summary stats, … Note that RStudio has a visual markdown editor that makes authoring longer documents more convenient. We will leave it at this short teaser for RMarkdown. There’s much more that RMarkdown can do, for example: insert references and bibliographies embed videos and interactive graphics parameterized reports for recurring reports. To learn more, check out one of the two big books of RMarkdown (Xie, Allaire, and Grolemund 2018; Xie, Dervieux, and Riederer 2020), or RStudios tutorial on RMarkdown (https://rmarkdown.rstudio.com/lesson-1.html). If you are a researcher, you might like RMarkdown for Scientists – A guide to RMarkdown aimed at researchers 9.3 Version control with Git Version control is an essential tool for any programming endeavour. It is like a time machine for your code. Among other things, version control allows you to store the state of your project and restore a previous state. create parallel versions (branches) of your code, switch between them and merge them back together collaborate with others on the same code, review and merge the changes that others have made Using version control is very liberating because it gives you the freedom to experiment and make mistakes. A popular version control tool is Git. To start using Git with your project you will need to do four things: Install Git initialize a new Git repository in your project directory. Decide which files and changes you want to save — there may be some files that you do not really need to track. For example, large intermediate data files may not be worth tracking if they can be easily recreated from the code. Commit the current state — A Git commit is to code what the 💾 is to a Word document. In principle you could use Git in the terminal, but there are many graphical user interfaces for Git that make things easier, and RStudio has a Git interface built in.16 git init git add . git commit -m &quot;initial commit&quot; Congratulations! You have made your first Git commit! Now you can rest assured, that you can always go back to the current state of the analysis, see the changes you have made since, figure out where things broke, and undo changes if necessary. Isn’t that comforting? To utilize the full power of Git, you will have to learn a few more things. This is outside of the scope of this book but you can find a good introduction to Git for R users in the book Happy Git with R (https://happygitwithr.com/). Learn to use Git and use it often! 9.4 Make your development environment reproducible 9.4.1 Snapshot packages with {renv} Unfortunately, using Git to track changes in your own code is not enough, because the packages that you use may get updated too and sometimes, the developers decide to change the way a function work. This can cause your code to break and it can be really frustrating to find that your analysis from a few months ago suddenly does not run anymore, or that it fails to run on your collaborators computer, who uses different versions of the same packages. You can avoid this frustration by storing a snapshot of your package library with the {renv} package (Ushey 2021). Install the {renv} package, then – in your project initialize {renv} for your project and take a snapshot of the packages you use in your project: install.packages(&quot;renv&quot;) renv::init() renv::snapshot() This creates a private, per-project library, in which new packages will be installed. This library is isolated from other R libraries on your system. Later, you or your collaborators can recreate this library, with the exact package versions you used by running renv::restore(). 9.4.2 Switching between R versions R itself receives updates, too. While the updates are often minor and breaking changes are rare, it is not guaranteed that today’s code will work on a future version of R. It is possible to install multiple versions of R in parallel on the same computer and switch between them. On Windows you can do this in the RStudio interface, Tools ▸ Global Options ▸ General ▸ Basic ▸ Use RStudio Version .... On MacOs, it is a little more complicated, but you can use a tool called RSwitch (https://rud.is/rswitch/) that makes it a bit easier. 9.4.3 Snapshot everything with Docker Finally, you can also take the idea of snapshotting your environment a step further by using Docker Containers. This is akin to creating an entire virtual computer just for your analysis. Instead of just your analysis files, you then track, store, and share that entire virtual computer. This is a lot more effort, but it may be the only way to guarantee that your analysis can be reproduced out of the box. However, this is beyond the scope of this book. 9.5 More R has many more tools for improving reproducibility, and as always there’s more than one option. 9.5.1 Pipelines Once your analysis becomes more complex it often contains many different outputs (models, figures, intermediate data sets). Some of them can take long to compute and it can be difficult to stay on top of the different steps of your analysis. There are packages that try to solve that. {targets} - smart make-files for your analysis {orderly} - makes sure your reproducible reports are reproducible {rrtols} 9.5.2 Test-driven development with {testthat}, {tinytest}. {testrmd} Personally, I prefer Github Desktop (https://desktop.github.com/) because it is prettier, snappier, and arguably more user friendly.↩︎ "],["an-awesome-community-1.html", "Reason 10 An awesome community 10.1 Get involved with the community 10.2 How to continue learning?", " Reason 10 An awesome community How to engage with the R community Great free learning resources We are almost at the end of this short introduction to R. We have barely scratched the surface of what R has to offer, but I hope, this has helped you figure out whether R is for you and whether you want to learn more about it. If you do, I think the best way is to find other people to learn from. 10.1 Get involved with the community R has an incredibly friendly, diverse, and welcoming community that is very open to beginners and loves to share knowledge, and because R is so widespread, there’s always an R nerd nearby who’s willing to help. Don’t be afraid to ask questions! Here are some ideas how you could engage with the community: The Twitter hashtag #RStats is a good way keep track of all the new things in the R world and “talk shop” with other R nerds. R conferences and user groups are a good place to meet other R users. Jumping rivers is maintaining a list. (https://jumpingrivers.github.io/meetingsR/index.html). If there is non in your area, why not create your own? There is also a R for Data Science learning community that organizes community learning events such as Tidy Tuesday – a weekly data visualization challenge. Participate in Tidy Tuesday to sharpen your data wrangling and data visualization skills and see how other people are approaching the same data. Write your own package or contribute to packages. This is an excellent way to become a better R programmer. 10.2 How to continue learning? Another thing that is unique about the R community is that R is mainly used by (and taught to) people who are not software engineers or computer scientists. As a result there is a lot of learning material that is made for people without a technical background. Amazingly, much of it is generously made available for free and really good! I will present just a few personal recommendations. The Awesome R Learning Resources List provides a more comprehensive list of resources for learning R, and Flavio Azevedo has compiled a list of R Tutorials on YouTube. R user groups and conferences also often put their talks online. See, for example, the RStudio presentations. An excellent book to pick up next would be R for Data Science. It provides a comprehensive overview of the Tidyverse. If you are working in education, then also check out R for Education — a handbook for teaching and learning with R and RStudio. Finally, the Carpentries are an organisation that teaches scientific computing skills to researchers, including R courses for beginners. Many universities and research institutes offer Carpentries courses for free to their students and employees. The material is available online, e.g., R for Social Sciences and R for Ecologists. "],["conclusions.html", "Conclusions", " Conclusions I hope you enjoyed this book and it has helped you in some way. If it did, why not share it with other people that you think might like it. I would also be happy to get some feedback. "],["acknowledgements.html", "Acknowledgements", " Acknowledgements The beautiful font used throughout most of this book is Junction by The League of Movable Type (https://www.theleagueofmoveabletype.com/junction). The title is set in Londrina by Marcelo Magalhães (http://www.marcelomagalhaes.net/). This book is made possible by the power of R (R Core Team 2021) and the amazing {bookdown} package (Xie 2016). "],["software-information.html", "Software Information", " Software Information sessionInfo() R version 4.1.0 (2021-05-18) Platform: x86_64-apple-darwin17.0 (64-bit) Running under: macOS Catalina 10.15.7 Matrix products: default BLAS: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRblas.dylib LAPACK: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRlapack.dylib locale: [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] sass_0.4.0 skimr_2.1.3 forcats_0.5.1 stringr_1.4.0 [5] dplyr_1.0.7 purrr_0.3.4 readr_2.0.0 tidyr_1.1.3 [9] tibble_3.1.2 ggplot2_3.3.5 tidyverse_1.3.1 vembedr_0.1.4 loaded via a namespace (and not attached): [1] Rcpp_1.0.7 lubridate_1.7.10 assertthat_0.2.1 digest_0.6.27 [5] utf8_1.2.1 R6_2.5.0 cellranger_1.1.0 repr_1.1.3 [9] backports_1.2.1 reprex_2.0.0 evaluate_0.14 httr_1.4.2 [13] highr_0.9 pillar_1.6.1 rlang_0.4.11 readxl_1.3.1 [17] rstudioapi_0.13 rmarkdown_2.9 bit_4.0.4 munsell_0.5.0 [21] broom_0.7.8 compiler_4.1.0 modelr_0.1.8 xfun_0.24 [25] pkgconfig_2.0.3 base64enc_0.1-3 htmltools_0.5.1.1 tidyselect_1.1.1 [29] bookdown_0.22 fansi_0.5.0 crayon_1.4.1 tzdb_0.1.2 [33] dbplyr_2.1.1 withr_2.4.2 grid_4.1.0 jsonlite_1.7.2 [37] gtable_0.3.0 lifecycle_1.0.0 DBI_1.1.1 magrittr_2.0.1 [41] scales_1.1.1 cli_3.0.1 stringi_1.7.3 vroom_1.5.3 [45] fs_1.5.0 xml2_1.3.2 ellipsis_0.3.2 generics_0.1.0 [49] vctrs_0.3.8 tools_4.1.0 bit64_4.0.5 glue_1.4.2 [53] hms_1.1.0 parallel_4.1.0 yaml_2.2.1 colorspace_2.0-2 [57] rvest_1.0.0 knitr_1.33 haven_2.4.1 "],["references.html", "References", " References "]]
